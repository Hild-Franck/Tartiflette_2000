<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Tarti-game.v0.2.0.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Tarti-game.v0.2.0.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Created by Hild Franck on 7/8/2015.
 */

/**
 * L'objet du jeu
 * @class
 * @property {HTMLCanvasElement} canvas Le canvas dans lequel le jeu tourne
 * @property {CanvasRenderingContext2D} context Spécification des méthodes et propriétés du canvas
 * @property {Number} fps Nombre de frames par seconde
 * @property {Number} xOffSet Nombre de pixel de décalage entre l'origine du dessin et l'origine du canvas sur l'axe x
 * @property {Number} yOffSet Nombre de pixel de décalage entre l'origine du dessin et l'origine du canvas sur l'axe y
 */
var game = {
    /** @lends game */
    canvas: document.getElementById("canvas"),
    context: canvas.getContext("2d"),

    fps: 60,
    xOffSet: 0,
    yOffSet: 0,
    /**
     * @class
     */
    objects:{
        entities: [],
        gui: [],

        /**
         * Fonction d'ajout d'un objet dans un tableau d'objets
         * @param arr Le tableau dans lequel l'objet est placé
         * @param obj L'objet à placer
         */
        add: function(arr, obj){
            arr.push(obj);
        },
        /**
         * Fonction qui rafraichi une liste d'objets à afficher
         * @param arr Le tableau à rafraichir
         * @param obj L'objet à rajouter au tableau
         */
        refresh: function(arr, obj){
            arr.push(obj);
            Array.prototype.push.call(this, arr);
            this.arrange();
        },
        /**
         * Fonction qui tri les objets selon leur variable y
         */
        arrange: function(){
                game.objects[0].sort(function(a, b){
                    if(a.y &lt; b.y)
                        return -1;
                    if(a.y > b.y)
                        return 1;
                    return 0;
                });
        }
    },
    /**
     * L'objet de la carte
     * @class
     * @property {Object} tileSheet Contient le fichier du layout de la map
     * @property {Number} height Hauteur de la map (nombre de tiles)
     * @property {Number} width Largeur de la map (nombre de tiles)
     */
    map:{
        tileSheet: new Image(),
        height: 10,
        width: 10,
        /**
         * Fonction qui initialise la map
         * @param {Object} tileSheetFile Le fichier de tiles à utiliser
         * @param {Number} [_width=10] Largeur de la map
         * @param {Number} [_height=10] Hauteur de la map
         */
        init: function(tileSheetFile, _width, _height){
            this.tileSheet.src = "resources/graphics/" + tileSheetFile;
            if(_width !== undefined)
                this.width = _width;
            if(_height !== undefined)
                this.height = _height;
        },
        /**
         * Fonction qui dessine une tile
         * @param x Coordonnée x de la tile sur le tilesheet
         * @param y Coordonnée y de la tile sur le tilesheet
         */
        dispTile: function(x, y){
            game.context.drawImage(this.tileSheet, 0, 0, 32, 32, x, y, 32, 32);
        },
        /**
         * Fonction qui dessine la map
         */
        drawMap: function(){
            for (var i = 0; i &lt; this.width; i++) {
                for (var j = 0; j &lt; this.height; j++) {
                    this.dispTile(32 * i + game.xOffSet, 32 * j + game.yOffSet);
                }
            }
        }
    },
    /**
     * Fonction qui initialise le jeu
     */
    init: function(){
        this.map.init("Outside_A2.png");
        this.addListeners();
    },
    /**
     * Fonction qui centre la caméra sur un objet
     * @param obj L'objet sur lequel la caméra sera centrée
     * @param pVwWdtOffset La largeur à partir de laquelle la caméra suit l'objet
     * @param pVwHgtOffset La hauteur à partir de laquelle la caméra suit l'objet
     */
    portview: function(obj, pVwWdtOffset, pVwHgtOffset){
        if(obj.x + this.xOffSet > this.canvas.width - pVwWdtOffset)
            this.xOffSet += (this.canvas.width - pVwWdtOffset) - (obj.x + this.xOffSet);
        if(obj.x + this.xOffSet &lt; 0 + pVwWdtOffset)
            this.xOffSet += pVwWdtOffset - (obj.x + this.xOffSet);
        if(obj.y + this.yOffSet > this.canvas.height - pVwHgtOffset)
            this.yOffSet += (canvas.height - pVwHgtOffset) - (obj.y + this.yOffSet);
        if(obj.y + this.yOffSet &lt; 0 + pVwWdtOffset)
            this.yOffSet += pVwHgtOffset - (obj.y + this.yOffSet);
    },
    /**
     * Ajoute les gestionnaires d'évènement
     */
    addListeners: function(){
        addEventListener("keydown", function(event){
            if(event.keyCode == 68)
                player.rightSwitch = true;
            if(event.keyCode == 81)
                player.leftSwitch = true;
            if(event.keyCode == 90)
                player.upSwitch = true;
            if(event.keyCode == 83)
                player.downSwitch = true;
        }, true);
        addEventListener("keyup", function(event){
            if(event.keyCode == 68)
                player.rightSwitch = false;
            if(event.keyCode == 81)
                player.leftSwitch = false;
            if(event.keyCode == 90)
                player.upSwitch = false;
            if(event.keyCode == 83)
                player.downSwitch = false;
            if(event.keyCode == 69)
                player.attack();
        }, true);
    },
    /**
     * Anime le sprite d'un objet
     * @param obj L'objet à animer
     */
    animate: function(obj){
        this.drawObj(obj, (obj.frame + 3 * obj.sprite), obj.sprInd,obj.x,obj.y);
        obj.countDraw++;

        if (obj.countDraw == game.fps)
            obj.countDraw = 0;
        if (obj.countDraw % Math.floor(game.fps / obj.nbrFrame) == 0)
            obj.frame++;
        if (obj.frame >= obj.nbrFrame)
            obj.frame = 0;

        if(obj.xPrev == obj.x &amp;&amp; obj.yPrev == obj.y)
            obj.frame = 1;
    },
    /**
     * Dessine les objets listés
     */
    drawObjects: function(){
        for(var i = 0; i &lt; game.objects.entities.length; i++){
            game.objects.entities[i].draw();
        }
        for(i = 0; i &lt; game.objects.gui.length; i++){
            game.objects.gui[i].draw();
        }
    },
    drawObj: function(obj,sprIndX,sprIndY,posX,posY,width,height){
        width = typeof width !== 'undefined' ?  width : 1;
        height = typeof height !== 'undefined' ?  height : 1;
        posX = typeof posX !== 'undefined' ? posX : obj.x;
        posY= typeof posY !== 'undefined' ? posY : obj.y;

        game.context.drawImage(obj.spriteSheet,  sprIndX * 32 , sprIndY * 32, width * 32, height * 32, posX + game.xOffSet - obj.xSpot, posY + game.yOffSet - obj.ySpot, width * 32,height * 32);
    },
    /**
     * Fonction permettant d'écirire du texte à l'écran
     * @param text Le texte à afficher
     * @param x La coordonnée x de l'affichage
     * @param y La coordonnée x de l'affichage
     * @param color La couleur du texte
     * @param opacity
     * @param size
     * @param align
     * @param isStatic
     */
    writeText: function(text, x, y, color, opacity, size, align, isStatic){
        this.context.font = typeof size !== "undefined" ? size.toString() +  "px sans-serif" : "10px sans-serif";
        this.context.textAlign = typeof align !== "undefined" ? align : "left";
        this.context.fillStyle = typeof color !== 'undefined' ? color : "black";
        this.context.globalAlpha = typeof opacity !== 'undefined' ? opacity : 1;
        isStatic = typeof isStatic !== 'undefined' ? isStatic : false;
        if(isStatic)
            this.context.fillText(text,x,y);
        else
            this.context.fillText(text,x + game.xOffSet,y + game.yOffSet);
        this.context.globalAlpha = 1;
    },
    /**
     * Constructeur d'un objet de texte spécial
     * @param _creator L'objet à l'origine de la création du texte
     * @param _text Le texte à afficher
     * @constructor
     */
    TextFx: function(_creator, _text){
        this.creator = _creator;
        this.text = _text;

        this.yOffset = 0;
        this.x = this.creator.x;
        this.y = this.creator.y - 20;
        this.opacity = 1;


        this.draw = function(){
            if(this.opacity > 0){
                game.writeText(this.text,this.x,this.y - this.yOffset,"blue",this.opacity, 15, "center");
                this.yOffset++;
                this.opacity -= 0.03;
            }
            else
                game.objects.gui.splice(game.objects.gui.indexOf(this), 1);
        }
    },
    /**
     * Fonction qui permet de créer un objet de texte spécial
     * @param creator Le créateur du texte
     * @param text Le texte à afficher
     * @returns {game.TextFx} Retourne l'objet texte
     */
    createTxtFx: function(creator, text){
        game.objects.gui.push(new this.TextFx(creator, text));
    },
    /**
     * Fonction lancée à chaque frame
     */
    update: function(){
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
        this.map.drawMap();
        player.update();
        this.portview(player,100,100);
        game.drawObjects();
        //player.draw();
        player.drawLife();
        if(!socket.connected){
            this.context.font = "20px Arial";
            this.context.fillStyle = "red";
            this.context.textAlign = "center";
            this.context.fillText("Connexion en cours...", this.canvas.width/2, this.canvas.height/2)
        }
    }
};

/**
 * L'objet du joueur
 * @class
 */
var player = {
    spriteSheet: new Image(),
    countDraw: 0,
    frame: 0,
    nbrFrame: 3,
    sprite: 1,
    sprInd: 0,

    heigth: 32,
    width: 32,


    x: 60,
    y: 60,
    xPrev: 0,
    yPrev: 0,
    xSpot: 16,
    ySpot: 16,
    speed: 4,

    maxHp: 1000,
    currentHp: 920,

    leftSwitch: false,
    rightSwitch: false,
    upSwitch: false,
    downSwitch: false,

    /**
     * Fonction d'initialisation du personnage
     * @param _sprite Sprite du personnage
     * @param xStart Coordonnée x de départ du personnage
     * @param yStart Coordonnée y de départ du personnage
     */
    init: function(_sprite, xStart, yStart){
        this.spriteSheet.src = "resources/graphics/Actor1.png";
        this.x = (xStart !== undefined) ? xStart : this.x;
        this.y = (yStart !== undefined) ? yStart : this.y;
        this.sprite = (_sprite !== undefined) ? _sprite : this.sprite;
        game.objects.add(game.objects.entities, this);
    },

    /**
     * Gère l'attaque du personnage
     */
    attack: function(){
        console.log("Attaque !");
        game.createTxtFx(this, "Attaque lancée !");
        socket.emit('message', 'Attaque lancée !');
    },

    draw: function(){
        game.animate(this);
    },
    /**
     * Dessine la vie du joueur
     */
    drawLife: function(){
        game.context.strokeRect(5,5,101,21);
        game.context.fillStyle = "#E00000";
        game.context.fillRect(6,6,this.currentHp / this.maxHp * 99,19);
        game.writeText("HP",110,20,"E00000",1, 10,"left", true);
    },

    /**
     * Fonction de mise à jour du personnage à chaque frame
     */
    update: function(){
        this.xPrev = this.x;
        this.yPrev = this.y;

        if(this.leftSwitch &amp;&amp; this.upSwitch){
            this.x -= this.speed/Math.sqrt(2);
            this.y -= this.speed/Math.sqrt(2);
        }
        else if(this.leftSwitch &amp;&amp; this.downSwitch){
            this.x -= this.speed/Math.sqrt(2);
            this.y += this.speed/Math.sqrt(2);
        }
        else if(this.rightSwitch &amp;&amp; this.upSwitch){
            this.x += this.speed/Math.sqrt(2);
            this.y -= this.speed/Math.sqrt(2);
        }
        else if(this.rightSwitch &amp;&amp; this.downSwitch){
            this.x += this.speed/Math.sqrt(2);
            this.y += this.speed/Math.sqrt(2);
        }
        else{
            if(this.leftSwitch) {
                this.x -= this.speed;
                this.sprInd = 1;
            }
            if(this.rightSwitch) {
                this.x += this.speed;
                this.sprInd = 2;
            }
            if(this.upSwitch) {
                this.y -= this.speed;
                this.sprInd = 3;
            }
            if(this.downSwitch) {
                this.y += this.speed;
                this.sprInd = 0;
            }
        }

    }
};
//--- Initialisation ---
debug = new Debug();
game.init();
player.init();

//--- Game loop ---
setInterval(function(){
    debug.clear();
    game.update();
    debug.monitor("x: ", player.x);
    debug.monitor("y: ", player.y);
    debug.monitor("frame: ", player.frame);
    console.log(game.objects.gui);
    debug.show();
}, 1000/game.fps);</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="game.html">game</a></li><li><a href="game.map.html">map</a></li><li><a href="game.objects.html">objects</a></li><li><a href="game.TextFx.html">TextFx</a></li><li><a href="player.html">player</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0-dev</a> on Thu Aug 06 2015 15:05:39 GMT+0200 (CEST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
